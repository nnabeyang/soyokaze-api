//
// DO NOT EDIT
//
// Generated by swift-atproto
//

import SwiftAtproto
import Foundation

extension appbskytypes {
    public struct NotificationDefs_ActivitySubscription: Codable, Sendable {
        public var post: Bool
        public var reply: Bool
        public var _unknownValues: [String: AnyCodable]

        public init(post: Bool, reply: Bool) {
            self.post = post
            self.reply = reply
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case post
            case reply
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.post = try keyedContainer.decode(Bool.self, forKey: .post)
            self.reply = try keyedContainer.decode(Bool.self, forKey: .reply)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.post, forKey: .post)
            try container.encode(self.reply, forKey: .reply)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct NotificationDefs_ChatPreference: Codable, Sendable {
        public var include: NotificationDefs_ChatPreference_Include
        public var push: Bool
        public var _unknownValues: [String: AnyCodable]

        public init(include: NotificationDefs_ChatPreference_Include, push: Bool) {
            self.include = include
            self.push = push
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case include
            case push
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.include = try keyedContainer.decode(NotificationDefs_ChatPreference_Include.self, forKey: .include)
            self.push = try keyedContainer.decode(Bool.self, forKey: .push)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.include, forKey: .include)
            try container.encode(self.push, forKey: .push)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum NotificationDefs_ChatPreference_Include: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case all
        case accepted
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "all":
                self = .all
            case "accepted":
                self = .accepted
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .all:
                "all"
            case .accepted:
                "accepted"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct NotificationDefs_FilterablePreference: Codable, Sendable {
        public var include: NotificationDefs_FilterablePreference_Include
        public var list: Bool
        public var push: Bool
        public var _unknownValues: [String: AnyCodable]

        public init(include: NotificationDefs_FilterablePreference_Include, list: Bool, push: Bool) {
            self.include = include
            self.list = list
            self.push = push
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case include
            case list
            case push
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.include = try keyedContainer.decode(NotificationDefs_FilterablePreference_Include.self, forKey: .include)
            self.list = try keyedContainer.decode(Bool.self, forKey: .list)
            self.push = try keyedContainer.decode(Bool.self, forKey: .push)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.include, forKey: .include)
            try container.encode(self.list, forKey: .list)
            try container.encode(self.push, forKey: .push)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum NotificationDefs_FilterablePreference_Include: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case all
        case follows
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "all":
                self = .all
            case "follows":
                self = .follows
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .all:
                "all"
            case .follows:
                "follows"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct NotificationDefs_Preference: Codable, Sendable {
        public var list: Bool
        public var push: Bool
        public var _unknownValues: [String: AnyCodable]

        public init(list: Bool, push: Bool) {
            self.list = list
            self.push = push
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case list
            case push
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.list = try keyedContainer.decode(Bool.self, forKey: .list)
            self.push = try keyedContainer.decode(Bool.self, forKey: .push)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.list, forKey: .list)
            try container.encode(self.push, forKey: .push)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct NotificationDefs_Preferences: Codable, Sendable {
        public var chat: NotificationDefs_ChatPreference
        public var follow: NotificationDefs_FilterablePreference
        public var like: NotificationDefs_FilterablePreference
        public var likeViaRepost: NotificationDefs_FilterablePreference
        public var mention: NotificationDefs_FilterablePreference
        public var quote: NotificationDefs_FilterablePreference
        public var reply: NotificationDefs_FilterablePreference
        public var repost: NotificationDefs_FilterablePreference
        public var repostViaRepost: NotificationDefs_FilterablePreference
        public var starterpackJoined: NotificationDefs_Preference
        public var subscribedPost: NotificationDefs_Preference
        public var unverified: NotificationDefs_Preference
        public var verified: NotificationDefs_Preference
        public var _unknownValues: [String: AnyCodable]

        public init(chat: NotificationDefs_ChatPreference, follow: NotificationDefs_FilterablePreference, like: NotificationDefs_FilterablePreference, likeViaRepost: NotificationDefs_FilterablePreference, mention: NotificationDefs_FilterablePreference, quote: NotificationDefs_FilterablePreference, reply: NotificationDefs_FilterablePreference, repost: NotificationDefs_FilterablePreference, repostViaRepost: NotificationDefs_FilterablePreference, starterpackJoined: NotificationDefs_Preference, subscribedPost: NotificationDefs_Preference, unverified: NotificationDefs_Preference, verified: NotificationDefs_Preference) {
            self.chat = chat
            self.follow = follow
            self.like = like
            self.likeViaRepost = likeViaRepost
            self.mention = mention
            self.quote = quote
            self.reply = reply
            self.repost = repost
            self.repostViaRepost = repostViaRepost
            self.starterpackJoined = starterpackJoined
            self.subscribedPost = subscribedPost
            self.unverified = unverified
            self.verified = verified
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case chat
            case follow
            case like
            case likeViaRepost
            case mention
            case quote
            case reply
            case repost
            case repostViaRepost
            case starterpackJoined
            case subscribedPost
            case unverified
            case verified
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.chat = try keyedContainer.decode(NotificationDefs_ChatPreference.self, forKey: .chat)
            self.follow = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .follow)
            self.like = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .like)
            self.likeViaRepost = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .likeViaRepost)
            self.mention = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .mention)
            self.quote = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .quote)
            self.reply = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .reply)
            self.repost = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .repost)
            self.repostViaRepost = try keyedContainer.decode(NotificationDefs_FilterablePreference.self, forKey: .repostViaRepost)
            self.starterpackJoined = try keyedContainer.decode(NotificationDefs_Preference.self, forKey: .starterpackJoined)
            self.subscribedPost = try keyedContainer.decode(NotificationDefs_Preference.self, forKey: .subscribedPost)
            self.unverified = try keyedContainer.decode(NotificationDefs_Preference.self, forKey: .unverified)
            self.verified = try keyedContainer.decode(NotificationDefs_Preference.self, forKey: .verified)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.chat, forKey: .chat)
            try container.encode(self.follow, forKey: .follow)
            try container.encode(self.like, forKey: .like)
            try container.encode(self.likeViaRepost, forKey: .likeViaRepost)
            try container.encode(self.mention, forKey: .mention)
            try container.encode(self.quote, forKey: .quote)
            try container.encode(self.reply, forKey: .reply)
            try container.encode(self.repost, forKey: .repost)
            try container.encode(self.repostViaRepost, forKey: .repostViaRepost)
            try container.encode(self.starterpackJoined, forKey: .starterpackJoined)
            try container.encode(self.subscribedPost, forKey: .subscribedPost)
            try container.encode(self.unverified, forKey: .unverified)
            try container.encode(self.verified, forKey: .verified)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct NotificationDefs_RecordDeleted: Codable, Sendable {
        public let type = "app.bsky.notification.defs#recordDeleted"
        public var _unknownValues: [String: AnyCodable]

        public init() {
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case type = "$type"
        }

        public init(from decoder: any Decoder) throws {
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct NotificationDefs_SubjectActivitySubscription: Codable, Sendable {
        public var activitySubscription: NotificationDefs_ActivitySubscription
        public var subject: String
        public var _unknownValues: [String: AnyCodable]

        public init(activitySubscription: NotificationDefs_ActivitySubscription, subject: String) {
            self.activitySubscription = activitySubscription
            self.subject = subject
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case activitySubscription
            case subject
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.activitySubscription = try keyedContainer.decode(NotificationDefs_ActivitySubscription.self, forKey: .activitySubscription)
            self.subject = try keyedContainer.decode(String.self, forKey: .subject)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.activitySubscription, forKey: .activitySubscription)
            try container.encode(self.subject, forKey: .subject)
            try _unknownValues.encode(to: encoder)
        }
    }
}

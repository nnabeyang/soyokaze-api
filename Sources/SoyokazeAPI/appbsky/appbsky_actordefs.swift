//
// DO NOT EDIT
//
// Generated by swift-atproto
//

import SwiftAtproto
import Foundation

extension appbskytypes {
    public struct ActorDefs_AdultContentPref: Codable, Sendable {
        public var enabled: Bool
        public let _unknownValues: [String: AnyCodable]

        public init(enabled: Bool) {
            self.enabled = enabled
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case enabled
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.enabled = try keyedContainer.decode(Bool.self, forKey: .enabled)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.enabled, forKey: .enabled)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_BskyAppProgressGuide: Codable, Sendable {
        public var guide: String
        public let _unknownValues: [String: AnyCodable]

        public init(guide: String) {
            self.guide = guide
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case guide
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.guide = try keyedContainer.decode(String.self, forKey: .guide)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.guide, forKey: .guide)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_BskyAppStatePref: Codable, Sendable {
        public var activeProgressGuide: ActorDefs_BskyAppProgressGuide?
        public var nuxs: [ActorDefs_Nux]?
        public var queuedNudges: [String]?
        public let _unknownValues: [String: AnyCodable]

        public init(activeProgressGuide: ActorDefs_BskyAppProgressGuide? = nil, nuxs: [ActorDefs_Nux]? = nil, queuedNudges: [String]? = nil) {
            self.activeProgressGuide = activeProgressGuide
            self.nuxs = nuxs
            self.queuedNudges = queuedNudges
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case activeProgressGuide
            case nuxs
            case queuedNudges
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.activeProgressGuide = try keyedContainer.decodeIfPresent(ActorDefs_BskyAppProgressGuide.self, forKey: .activeProgressGuide)
            self.nuxs = try keyedContainer.decodeIfPresent([ActorDefs_Nux].self, forKey: .nuxs)
            self.queuedNudges = try keyedContainer.decodeIfPresent([String].self, forKey: .queuedNudges)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.activeProgressGuide, forKey: .activeProgressGuide)
            try container.encodeIfPresent(self.nuxs, forKey: .nuxs)
            try container.encodeIfPresent(self.queuedNudges, forKey: .queuedNudges)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_ContentLabelPref: Codable, Sendable {
        public var label: String
        public var labelerDid: String?
        public var visibility: ActorDefs_ContentLabelPref_Visibility
        public let _unknownValues: [String: AnyCodable]

        public init(label: String, labelerDid: String? = nil, visibility: ActorDefs_ContentLabelPref_Visibility) {
            self.label = label
            self.labelerDid = labelerDid
            self.visibility = visibility
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case label
            case labelerDid
            case visibility
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.label = try keyedContainer.decode(String.self, forKey: .label)
            self.labelerDid = try keyedContainer.decodeIfPresent(String.self, forKey: .labelerDid)
            self.visibility = try keyedContainer.decode(ActorDefs_ContentLabelPref_Visibility.self, forKey: .visibility)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.label, forKey: .label)
            try container.encodeIfPresent(self.labelerDid, forKey: .labelerDid)
            try container.encode(self.visibility, forKey: .visibility)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_ContentLabelPref_Visibility: RawRepresentable, Codable, Sendable {
        case ignore
        case show
        case warn
        case hide
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "ignore":
                self = .ignore
            case "show":
                self = .show
            case "warn":
                self = .warn
            case "hide":
                self = .hide
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .ignore:
                "ignore"
            case .show:
                "show"
            case .warn:
                "warn"
            case .hide:
                "hide"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_FeedViewPref: Codable, Sendable {
        public var feed: String
        public var hideQuotePosts: Bool?
        public var hideReplies: Bool?
        public var hideRepliesByLikeCount: Int?
        public var hideRepliesByUnfollowed: Bool?
        public var hideReposts: Bool?
        public let _unknownValues: [String: AnyCodable]

        public init(feed: String, hideQuotePosts: Bool? = nil, hideReplies: Bool? = nil, hideRepliesByLikeCount: Int? = nil, hideRepliesByUnfollowed: Bool? = nil, hideReposts: Bool? = nil) {
            self.feed = feed
            self.hideQuotePosts = hideQuotePosts
            self.hideReplies = hideReplies
            self.hideRepliesByLikeCount = hideRepliesByLikeCount
            self.hideRepliesByUnfollowed = hideRepliesByUnfollowed
            self.hideReposts = hideReposts
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case feed
            case hideQuotePosts
            case hideReplies
            case hideRepliesByLikeCount
            case hideRepliesByUnfollowed
            case hideReposts
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.feed = try keyedContainer.decode(String.self, forKey: .feed)
            self.hideQuotePosts = try keyedContainer.decodeIfPresent(Bool.self, forKey: .hideQuotePosts)
            self.hideReplies = try keyedContainer.decodeIfPresent(Bool.self, forKey: .hideReplies)
            self.hideRepliesByLikeCount = try keyedContainer.decodeIfPresent(Int.self, forKey: .hideRepliesByLikeCount)
            self.hideRepliesByUnfollowed = try keyedContainer.decodeIfPresent(Bool.self, forKey: .hideRepliesByUnfollowed)
            self.hideReposts = try keyedContainer.decodeIfPresent(Bool.self, forKey: .hideReposts)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.feed, forKey: .feed)
            try container.encodeIfPresent(self.hideQuotePosts, forKey: .hideQuotePosts)
            try container.encodeIfPresent(self.hideReplies, forKey: .hideReplies)
            try container.encodeIfPresent(self.hideRepliesByLikeCount, forKey: .hideRepliesByLikeCount)
            try container.encodeIfPresent(self.hideRepliesByUnfollowed, forKey: .hideRepliesByUnfollowed)
            try container.encodeIfPresent(self.hideReposts, forKey: .hideReposts)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_HiddenPostsPref: Codable, Sendable {
        public var items: [String]
        public let _unknownValues: [String: AnyCodable]

        public init(items: [String]) {
            self.items = items
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case items
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.items = try keyedContainer.decode([String].self, forKey: .items)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.items, forKey: .items)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_InterestsPref: Codable, Sendable {
        public var tags: [String]
        public let _unknownValues: [String: AnyCodable]

        public init(tags: [String]) {
            self.tags = tags
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case tags
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.tags = try keyedContainer.decode([String].self, forKey: .tags)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.tags, forKey: .tags)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_KnownFollowers: Codable, Sendable {
        public var count: Int
        public var followers: [ActorDefs_ProfileViewBasic]
        public let _unknownValues: [String: AnyCodable]

        public init(count: Int, followers: [ActorDefs_ProfileViewBasic]) {
            self.count = count
            self.followers = followers
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case count
            case followers
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.count = try keyedContainer.decode(Int.self, forKey: .count)
            self.followers = try keyedContainer.decode([ActorDefs_ProfileViewBasic].self, forKey: .followers)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.count, forKey: .count)
            try container.encode(self.followers, forKey: .followers)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_LabelerPrefItem: Codable, Sendable {
        public var did: String
        public let _unknownValues: [String: AnyCodable]

        public init(did: String) {
            self.did = did
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case did
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.did, forKey: .did)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_LabelersPref: Codable, Sendable {
        public var labelers: [ActorDefs_LabelerPrefItem]
        public let _unknownValues: [String: AnyCodable]

        public init(labelers: [ActorDefs_LabelerPrefItem]) {
            self.labelers = labelers
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case labelers
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.labelers = try keyedContainer.decode([ActorDefs_LabelerPrefItem].self, forKey: .labelers)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.labelers, forKey: .labelers)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_MutedWord: Codable, Sendable {
        public var actorTarget: ActorDefs_MutedWord_ActorTarget?
        public var expiresAt: String?
        public var id: String?
        public var targets: [ActorDefs_MutedWordTarget]
        public var value: String
        public let _unknownValues: [String: AnyCodable]

        public init(actorTarget: ActorDefs_MutedWord_ActorTarget? = nil, expiresAt: String? = nil, id: String? = nil, targets: [ActorDefs_MutedWordTarget], value: String) {
            self.actorTarget = actorTarget
            self.expiresAt = expiresAt
            self.id = id
            self.targets = targets
            self.value = value
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case actorTarget
            case expiresAt
            case id
            case targets
            case value
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.actorTarget = try keyedContainer.decodeIfPresent(ActorDefs_MutedWord_ActorTarget.self, forKey: .actorTarget)
            self.expiresAt = try keyedContainer.decodeIfPresent(String.self, forKey: .expiresAt)
            self.id = try keyedContainer.decodeIfPresent(String.self, forKey: .id)
            self.targets = try keyedContainer.decode([ActorDefs_MutedWordTarget].self, forKey: .targets)
            self.value = try keyedContainer.decode(String.self, forKey: .value)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.actorTarget, forKey: .actorTarget)
            try container.encodeIfPresent(self.expiresAt, forKey: .expiresAt)
            try container.encodeIfPresent(self.id, forKey: .id)
            try container.encode(self.targets, forKey: .targets)
            try container.encode(self.value, forKey: .value)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_MutedWord_ActorTarget: RawRepresentable, Codable, Sendable {
        case all
        case excludeFollowing
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "all":
                self = .all
            case "exclude-following":
                self = .excludeFollowing
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .all:
                "all"
            case .excludeFollowing:
                "exclude-following"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_MutedWordsPref: Codable, Sendable {
        public var items: [ActorDefs_MutedWord]
        public let _unknownValues: [String: AnyCodable]

        public init(items: [ActorDefs_MutedWord]) {
            self.items = items
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case items
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.items = try keyedContainer.decode([ActorDefs_MutedWord].self, forKey: .items)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.items, forKey: .items)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_MutedWordTarget: RawRepresentable, Codable, Sendable {
        case content
        case tag
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "content":
                self = .content
            case "tag":
                self = .tag
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .content:
                "content"
            case .tag:
                "tag"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_Nux: Codable, Sendable {
        public var completed: Bool
        public var data: String?
        public var expiresAt: String?
        public var id: String
        public let _unknownValues: [String: AnyCodable]

        public init(completed: Bool, data: String? = nil, expiresAt: String? = nil, id: String) {
            self.completed = completed
            self.data = data
            self.expiresAt = expiresAt
            self.id = id
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case completed
            case data
            case expiresAt
            case id
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.completed = try keyedContainer.decode(Bool.self, forKey: .completed)
            self.data = try keyedContainer.decodeIfPresent(String.self, forKey: .data)
            self.expiresAt = try keyedContainer.decodeIfPresent(String.self, forKey: .expiresAt)
            self.id = try keyedContainer.decode(String.self, forKey: .id)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.completed, forKey: .completed)
            try container.encodeIfPresent(self.data, forKey: .data)
            try container.encodeIfPresent(self.expiresAt, forKey: .expiresAt)
            try container.encode(self.id, forKey: .id)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_PersonalDetailsPref: Codable, Sendable {
        public var birthDate: String?
        public let _unknownValues: [String: AnyCodable]

        public init(birthDate: String? = nil) {
            self.birthDate = birthDate
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case birthDate
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.birthDate = try keyedContainer.decodeIfPresent(String.self, forKey: .birthDate)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.birthDate, forKey: .birthDate)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_PostInteractionSettingsPref: Codable, Sendable {
        public var postgateEmbeddingRules: [ActorDefs_PostInteractionSettingsPref_PostgateEmbeddingRules_Elem]?
        public var threadgateAllowRules: [ActorDefs_PostInteractionSettingsPref_ThreadgateAllowRules_Elem]?
        public let _unknownValues: [String: AnyCodable]

        public init(postgateEmbeddingRules: [ActorDefs_PostInteractionSettingsPref_PostgateEmbeddingRules_Elem]? = nil, threadgateAllowRules: [ActorDefs_PostInteractionSettingsPref_ThreadgateAllowRules_Elem]? = nil) {
            self.postgateEmbeddingRules = postgateEmbeddingRules
            self.threadgateAllowRules = threadgateAllowRules
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case postgateEmbeddingRules
            case threadgateAllowRules
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.postgateEmbeddingRules = try keyedContainer.decodeIfPresent([ActorDefs_PostInteractionSettingsPref_PostgateEmbeddingRules_Elem].self, forKey: .postgateEmbeddingRules)
            self.threadgateAllowRules = try keyedContainer.decodeIfPresent([ActorDefs_PostInteractionSettingsPref_ThreadgateAllowRules_Elem].self, forKey: .threadgateAllowRules)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.postgateEmbeddingRules, forKey: .postgateEmbeddingRules)
            try container.encodeIfPresent(self.threadgateAllowRules, forKey: .threadgateAllowRules)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_PostInteractionSettingsPref_PostgateEmbeddingRules_Elem: Codable, Sendable {
        case feedPostgateDisableRule(FeedPostgate_DisableRule)
        case _other(UnknownRecord)

        enum CodingKeys: String, CodingKey {
            case type = "$type"
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(String.self, forKey: .type)
            switch type {
            case "app.bsky.feed.postgate#disableRule":
                self = try .feedPostgateDisableRule(.init(from: decoder))
            default:
                self = try ._other(.init(from: decoder))
            }
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case let .feedPostgateDisableRule(value):
                try container.encode("app.bsky.feed.postgate#disableRule", forKey: .type)
                try value.encode(to: encoder)
            case let ._other(value):
                try value.encode(to: encoder)
            }
        }
    }

    public indirect enum ActorDefs_PostInteractionSettingsPref_ThreadgateAllowRules_Elem: Codable, Sendable {
        case feedThreadgateMentionRule(FeedThreadgate_MentionRule)
        case feedThreadgateFollowerRule(FeedThreadgate_FollowerRule)
        case feedThreadgateFollowingRule(FeedThreadgate_FollowingRule)
        case feedThreadgateListRule(FeedThreadgate_ListRule)
        case _other(UnknownRecord)

        enum CodingKeys: String, CodingKey {
            case type = "$type"
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(String.self, forKey: .type)
            switch type {
            case "app.bsky.feed.threadgate#mentionRule":
                self = try .feedThreadgateMentionRule(.init(from: decoder))
            case "app.bsky.feed.threadgate#followerRule":
                self = try .feedThreadgateFollowerRule(.init(from: decoder))
            case "app.bsky.feed.threadgate#followingRule":
                self = try .feedThreadgateFollowingRule(.init(from: decoder))
            case "app.bsky.feed.threadgate#listRule":
                self = try .feedThreadgateListRule(.init(from: decoder))
            default:
                self = try ._other(.init(from: decoder))
            }
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case let .feedThreadgateMentionRule(value):
                try container.encode("app.bsky.feed.threadgate#mentionRule", forKey: .type)
                try value.encode(to: encoder)
            case let .feedThreadgateFollowerRule(value):
                try container.encode("app.bsky.feed.threadgate#followerRule", forKey: .type)
                try value.encode(to: encoder)
            case let .feedThreadgateFollowingRule(value):
                try container.encode("app.bsky.feed.threadgate#followingRule", forKey: .type)
                try value.encode(to: encoder)
            case let .feedThreadgateListRule(value):
                try container.encode("app.bsky.feed.threadgate#listRule", forKey: .type)
                try value.encode(to: encoder)
            case let ._other(value):
                try value.encode(to: encoder)
            }
        }
    }

    public indirect enum ActorDefs_Preferences_Elem: Codable, Sendable {
        case actorDefsAdultContentPref(ActorDefs_AdultContentPref)
        case actorDefsContentLabelPref(ActorDefs_ContentLabelPref)
        case actorDefsSavedFeedsPref(ActorDefs_SavedFeedsPref)
        case actorDefsSavedFeedsPrefV2(ActorDefs_SavedFeedsPrefV2)
        case actorDefsPersonalDetailsPref(ActorDefs_PersonalDetailsPref)
        case actorDefsFeedViewPref(ActorDefs_FeedViewPref)
        case actorDefsThreadViewPref(ActorDefs_ThreadViewPref)
        case actorDefsInterestsPref(ActorDefs_InterestsPref)
        case actorDefsMutedWordsPref(ActorDefs_MutedWordsPref)
        case actorDefsHiddenPostsPref(ActorDefs_HiddenPostsPref)
        case actorDefsBskyAppStatePref(ActorDefs_BskyAppStatePref)
        case actorDefsLabelersPref(ActorDefs_LabelersPref)
        case actorDefsPostInteractionSettingsPref(ActorDefs_PostInteractionSettingsPref)
        case actorDefsVerificationPrefs(ActorDefs_VerificationPrefs)
        case _other(UnknownRecord)

        enum CodingKeys: String, CodingKey {
            case type = "$type"
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(String.self, forKey: .type)
            switch type {
            case "app.bsky.actor.defs#adultContentPref":
                self = try .actorDefsAdultContentPref(.init(from: decoder))
            case "app.bsky.actor.defs#contentLabelPref":
                self = try .actorDefsContentLabelPref(.init(from: decoder))
            case "app.bsky.actor.defs#savedFeedsPref":
                self = try .actorDefsSavedFeedsPref(.init(from: decoder))
            case "app.bsky.actor.defs#savedFeedsPrefV2":
                self = try .actorDefsSavedFeedsPrefV2(.init(from: decoder))
            case "app.bsky.actor.defs#personalDetailsPref":
                self = try .actorDefsPersonalDetailsPref(.init(from: decoder))
            case "app.bsky.actor.defs#feedViewPref":
                self = try .actorDefsFeedViewPref(.init(from: decoder))
            case "app.bsky.actor.defs#threadViewPref":
                self = try .actorDefsThreadViewPref(.init(from: decoder))
            case "app.bsky.actor.defs#interestsPref":
                self = try .actorDefsInterestsPref(.init(from: decoder))
            case "app.bsky.actor.defs#mutedWordsPref":
                self = try .actorDefsMutedWordsPref(.init(from: decoder))
            case "app.bsky.actor.defs#hiddenPostsPref":
                self = try .actorDefsHiddenPostsPref(.init(from: decoder))
            case "app.bsky.actor.defs#bskyAppStatePref":
                self = try .actorDefsBskyAppStatePref(.init(from: decoder))
            case "app.bsky.actor.defs#labelersPref":
                self = try .actorDefsLabelersPref(.init(from: decoder))
            case "app.bsky.actor.defs#postInteractionSettingsPref":
                self = try .actorDefsPostInteractionSettingsPref(.init(from: decoder))
            case "app.bsky.actor.defs#verificationPrefs":
                self = try .actorDefsVerificationPrefs(.init(from: decoder))
            default:
                self = try ._other(.init(from: decoder))
            }
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case let .actorDefsAdultContentPref(value):
                try container.encode("app.bsky.actor.defs#adultContentPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsContentLabelPref(value):
                try container.encode("app.bsky.actor.defs#contentLabelPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsSavedFeedsPref(value):
                try container.encode("app.bsky.actor.defs#savedFeedsPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsSavedFeedsPrefV2(value):
                try container.encode("app.bsky.actor.defs#savedFeedsPrefV2", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsPersonalDetailsPref(value):
                try container.encode("app.bsky.actor.defs#personalDetailsPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsFeedViewPref(value):
                try container.encode("app.bsky.actor.defs#feedViewPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsThreadViewPref(value):
                try container.encode("app.bsky.actor.defs#threadViewPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsInterestsPref(value):
                try container.encode("app.bsky.actor.defs#interestsPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsMutedWordsPref(value):
                try container.encode("app.bsky.actor.defs#mutedWordsPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsHiddenPostsPref(value):
                try container.encode("app.bsky.actor.defs#hiddenPostsPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsBskyAppStatePref(value):
                try container.encode("app.bsky.actor.defs#bskyAppStatePref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsLabelersPref(value):
                try container.encode("app.bsky.actor.defs#labelersPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsPostInteractionSettingsPref(value):
                try container.encode("app.bsky.actor.defs#postInteractionSettingsPref", forKey: .type)
                try value.encode(to: encoder)
            case let .actorDefsVerificationPrefs(value):
                try container.encode("app.bsky.actor.defs#verificationPrefs", forKey: .type)
                try value.encode(to: encoder)
            case let ._other(value):
                try value.encode(to: encoder)
            }
        }
    }

    public struct ActorDefs_ProfileAssociated: Codable, Sendable {
        public var activitySubscription: ActorDefs_ProfileAssociatedActivitySubscription?
        public var chat: ActorDefs_ProfileAssociatedChat?
        public var feedgens: Int?
        public var labeler: Bool?
        public var lists: Int?
        public var starterPacks: Int?
        public let _unknownValues: [String: AnyCodable]

        public init(activitySubscription: ActorDefs_ProfileAssociatedActivitySubscription? = nil, chat: ActorDefs_ProfileAssociatedChat? = nil, feedgens: Int? = nil, labeler: Bool? = nil, lists: Int? = nil, starterPacks: Int? = nil) {
            self.activitySubscription = activitySubscription
            self.chat = chat
            self.feedgens = feedgens
            self.labeler = labeler
            self.lists = lists
            self.starterPacks = starterPacks
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case activitySubscription
            case chat
            case feedgens
            case labeler
            case lists
            case starterPacks
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.activitySubscription = try keyedContainer.decodeIfPresent(ActorDefs_ProfileAssociatedActivitySubscription.self, forKey: .activitySubscription)
            self.chat = try keyedContainer.decodeIfPresent(ActorDefs_ProfileAssociatedChat.self, forKey: .chat)
            self.feedgens = try keyedContainer.decodeIfPresent(Int.self, forKey: .feedgens)
            self.labeler = try keyedContainer.decodeIfPresent(Bool.self, forKey: .labeler)
            self.lists = try keyedContainer.decodeIfPresent(Int.self, forKey: .lists)
            self.starterPacks = try keyedContainer.decodeIfPresent(Int.self, forKey: .starterPacks)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.activitySubscription, forKey: .activitySubscription)
            try container.encodeIfPresent(self.chat, forKey: .chat)
            try container.encodeIfPresent(self.feedgens, forKey: .feedgens)
            try container.encodeIfPresent(self.labeler, forKey: .labeler)
            try container.encodeIfPresent(self.lists, forKey: .lists)
            try container.encodeIfPresent(self.starterPacks, forKey: .starterPacks)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_ProfileAssociatedActivitySubscription: Codable, Sendable {
        public var allowSubscriptions: ActorDefs_ProfileAssociatedActivitySubscription_AllowSubscriptions
        public let _unknownValues: [String: AnyCodable]

        public init(allowSubscriptions: ActorDefs_ProfileAssociatedActivitySubscription_AllowSubscriptions) {
            self.allowSubscriptions = allowSubscriptions
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case allowSubscriptions
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.allowSubscriptions = try keyedContainer.decode(ActorDefs_ProfileAssociatedActivitySubscription_AllowSubscriptions.self, forKey: .allowSubscriptions)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.allowSubscriptions, forKey: .allowSubscriptions)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_ProfileAssociatedActivitySubscription_AllowSubscriptions: RawRepresentable, Codable, Sendable {
        case followers
        case mutuals
        case none
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "followers":
                self = .followers
            case "mutuals":
                self = .mutuals
            case "none":
                self = .none
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .followers:
                "followers"
            case .mutuals:
                "mutuals"
            case .none:
                "none"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_ProfileAssociatedChat: Codable, Sendable {
        public var allowIncoming: ActorDefs_ProfileAssociatedChat_AllowIncoming
        public let _unknownValues: [String: AnyCodable]

        public init(allowIncoming: ActorDefs_ProfileAssociatedChat_AllowIncoming) {
            self.allowIncoming = allowIncoming
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case allowIncoming
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.allowIncoming = try keyedContainer.decode(ActorDefs_ProfileAssociatedChat_AllowIncoming.self, forKey: .allowIncoming)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.allowIncoming, forKey: .allowIncoming)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_ProfileAssociatedChat_AllowIncoming: RawRepresentable, Codable, Sendable {
        case all
        case none
        case following
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "all":
                self = .all
            case "none":
                self = .none
            case "following":
                self = .following
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .all:
                "all"
            case .none:
                "none"
            case .following:
                "following"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_ProfileView: Codable, Sendable {
        public var associated: ActorDefs_ProfileAssociated?
        public var avatar: String?
        public var createdAt: String?
        public var description: String?
        public var did: String
        public var displayName: String?
        public var handle: String
        public var indexedAt: String?
        public var labels: [comatprototypes.LabelDefs_Label]?
        public var status: ActorDefs_StatusView?
        public var verification: ActorDefs_VerificationState?
        public var viewer: ActorDefs_ViewerState?
        public let _unknownValues: [String: AnyCodable]

        public init(associated: ActorDefs_ProfileAssociated? = nil, avatar: String? = nil, createdAt: String? = nil, description: String? = nil, did: String, displayName: String? = nil, handle: String, indexedAt: String? = nil, labels: [comatprototypes.LabelDefs_Label]? = nil, status: ActorDefs_StatusView? = nil, verification: ActorDefs_VerificationState? = nil, viewer: ActorDefs_ViewerState? = nil) {
            self.associated = associated
            self.avatar = avatar
            self.createdAt = createdAt
            self.description = description
            self.did = did
            self.displayName = displayName
            self.handle = handle
            self.indexedAt = indexedAt
            self.labels = labels
            self.status = status
            self.verification = verification
            self.viewer = viewer
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case associated
            case avatar
            case createdAt
            case description
            case did
            case displayName
            case handle
            case indexedAt
            case labels
            case status
            case verification
            case viewer
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.associated = try keyedContainer.decodeIfPresent(ActorDefs_ProfileAssociated.self, forKey: .associated)
            self.avatar = try keyedContainer.decodeIfPresent(String.self, forKey: .avatar)
            self.createdAt = try keyedContainer.decodeIfPresent(String.self, forKey: .createdAt)
            self.description = try keyedContainer.decodeIfPresent(String.self, forKey: .description)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.displayName = try keyedContainer.decodeIfPresent(String.self, forKey: .displayName)
            self.handle = try keyedContainer.decode(String.self, forKey: .handle)
            self.indexedAt = try keyedContainer.decodeIfPresent(String.self, forKey: .indexedAt)
            self.labels = try keyedContainer.decodeIfPresent([comatprototypes.LabelDefs_Label].self, forKey: .labels)
            self.status = try keyedContainer.decodeIfPresent(ActorDefs_StatusView.self, forKey: .status)
            self.verification = try keyedContainer.decodeIfPresent(ActorDefs_VerificationState.self, forKey: .verification)
            self.viewer = try keyedContainer.decodeIfPresent(ActorDefs_ViewerState.self, forKey: .viewer)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.associated, forKey: .associated)
            try container.encodeIfPresent(self.avatar, forKey: .avatar)
            try container.encodeIfPresent(self.createdAt, forKey: .createdAt)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.did, forKey: .did)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encode(self.handle, forKey: .handle)
            try container.encodeIfPresent(self.indexedAt, forKey: .indexedAt)
            try container.encodeIfPresent(self.labels, forKey: .labels)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.verification, forKey: .verification)
            try container.encodeIfPresent(self.viewer, forKey: .viewer)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_ProfileViewBasic: Codable, Sendable {
        public var associated: ActorDefs_ProfileAssociated?
        public var avatar: String?
        public var createdAt: String?
        public var did: String
        public var displayName: String?
        public var handle: String
        public var labels: [comatprototypes.LabelDefs_Label]?
        public var status: ActorDefs_StatusView?
        public var verification: ActorDefs_VerificationState?
        public var viewer: ActorDefs_ViewerState?
        public let _unknownValues: [String: AnyCodable]

        public init(associated: ActorDefs_ProfileAssociated? = nil, avatar: String? = nil, createdAt: String? = nil, did: String, displayName: String? = nil, handle: String, labels: [comatprototypes.LabelDefs_Label]? = nil, status: ActorDefs_StatusView? = nil, verification: ActorDefs_VerificationState? = nil, viewer: ActorDefs_ViewerState? = nil) {
            self.associated = associated
            self.avatar = avatar
            self.createdAt = createdAt
            self.did = did
            self.displayName = displayName
            self.handle = handle
            self.labels = labels
            self.status = status
            self.verification = verification
            self.viewer = viewer
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case associated
            case avatar
            case createdAt
            case did
            case displayName
            case handle
            case labels
            case status
            case verification
            case viewer
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.associated = try keyedContainer.decodeIfPresent(ActorDefs_ProfileAssociated.self, forKey: .associated)
            self.avatar = try keyedContainer.decodeIfPresent(String.self, forKey: .avatar)
            self.createdAt = try keyedContainer.decodeIfPresent(String.self, forKey: .createdAt)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.displayName = try keyedContainer.decodeIfPresent(String.self, forKey: .displayName)
            self.handle = try keyedContainer.decode(String.self, forKey: .handle)
            self.labels = try keyedContainer.decodeIfPresent([comatprototypes.LabelDefs_Label].self, forKey: .labels)
            self.status = try keyedContainer.decodeIfPresent(ActorDefs_StatusView.self, forKey: .status)
            self.verification = try keyedContainer.decodeIfPresent(ActorDefs_VerificationState.self, forKey: .verification)
            self.viewer = try keyedContainer.decodeIfPresent(ActorDefs_ViewerState.self, forKey: .viewer)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.associated, forKey: .associated)
            try container.encodeIfPresent(self.avatar, forKey: .avatar)
            try container.encodeIfPresent(self.createdAt, forKey: .createdAt)
            try container.encode(self.did, forKey: .did)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encode(self.handle, forKey: .handle)
            try container.encodeIfPresent(self.labels, forKey: .labels)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.verification, forKey: .verification)
            try container.encodeIfPresent(self.viewer, forKey: .viewer)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_ProfileViewDetailed: Codable, Sendable {
        public var associated: ActorDefs_ProfileAssociated?
        public var avatar: String?
        public var banner: String?
        public var createdAt: String?
        public var description: String?
        public var did: String
        public var displayName: String?
        public var followersCount: Int?
        public var followsCount: Int?
        public var handle: String
        public var indexedAt: String?
        public var joinedViaStarterPack: GraphDefs_StarterPackViewBasic?
        public var labels: [comatprototypes.LabelDefs_Label]?
        public var pinnedPost: comatprototypes.RepoStrongRef?
        public var postsCount: Int?
        public var status: ActorDefs_StatusView?
        public var verification: ActorDefs_VerificationState?
        public var viewer: ActorDefs_ViewerState?
        public let _unknownValues: [String: AnyCodable]

        public init(associated: ActorDefs_ProfileAssociated? = nil, avatar: String? = nil, banner: String? = nil, createdAt: String? = nil, description: String? = nil, did: String, displayName: String? = nil, followersCount: Int? = nil, followsCount: Int? = nil, handle: String, indexedAt: String? = nil, joinedViaStarterPack: GraphDefs_StarterPackViewBasic? = nil, labels: [comatprototypes.LabelDefs_Label]? = nil, pinnedPost: comatprototypes.RepoStrongRef? = nil, postsCount: Int? = nil, status: ActorDefs_StatusView? = nil, verification: ActorDefs_VerificationState? = nil, viewer: ActorDefs_ViewerState? = nil) {
            self.associated = associated
            self.avatar = avatar
            self.banner = banner
            self.createdAt = createdAt
            self.description = description
            self.did = did
            self.displayName = displayName
            self.followersCount = followersCount
            self.followsCount = followsCount
            self.handle = handle
            self.indexedAt = indexedAt
            self.joinedViaStarterPack = joinedViaStarterPack
            self.labels = labels
            self.pinnedPost = pinnedPost
            self.postsCount = postsCount
            self.status = status
            self.verification = verification
            self.viewer = viewer
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case associated
            case avatar
            case banner
            case createdAt
            case description
            case did
            case displayName
            case followersCount
            case followsCount
            case handle
            case indexedAt
            case joinedViaStarterPack
            case labels
            case pinnedPost
            case postsCount
            case status
            case verification
            case viewer
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.associated = try keyedContainer.decodeIfPresent(ActorDefs_ProfileAssociated.self, forKey: .associated)
            self.avatar = try keyedContainer.decodeIfPresent(String.self, forKey: .avatar)
            self.banner = try keyedContainer.decodeIfPresent(String.self, forKey: .banner)
            self.createdAt = try keyedContainer.decodeIfPresent(String.self, forKey: .createdAt)
            self.description = try keyedContainer.decodeIfPresent(String.self, forKey: .description)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.displayName = try keyedContainer.decodeIfPresent(String.self, forKey: .displayName)
            self.followersCount = try keyedContainer.decodeIfPresent(Int.self, forKey: .followersCount)
            self.followsCount = try keyedContainer.decodeIfPresent(Int.self, forKey: .followsCount)
            self.handle = try keyedContainer.decode(String.self, forKey: .handle)
            self.indexedAt = try keyedContainer.decodeIfPresent(String.self, forKey: .indexedAt)
            self.joinedViaStarterPack = try keyedContainer.decodeIfPresent(GraphDefs_StarterPackViewBasic.self, forKey: .joinedViaStarterPack)
            self.labels = try keyedContainer.decodeIfPresent([comatprototypes.LabelDefs_Label].self, forKey: .labels)
            self.pinnedPost = try keyedContainer.decodeIfPresent(comatprototypes.RepoStrongRef.self, forKey: .pinnedPost)
            self.postsCount = try keyedContainer.decodeIfPresent(Int.self, forKey: .postsCount)
            self.status = try keyedContainer.decodeIfPresent(ActorDefs_StatusView.self, forKey: .status)
            self.verification = try keyedContainer.decodeIfPresent(ActorDefs_VerificationState.self, forKey: .verification)
            self.viewer = try keyedContainer.decodeIfPresent(ActorDefs_ViewerState.self, forKey: .viewer)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.associated, forKey: .associated)
            try container.encodeIfPresent(self.avatar, forKey: .avatar)
            try container.encodeIfPresent(self.banner, forKey: .banner)
            try container.encodeIfPresent(self.createdAt, forKey: .createdAt)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encode(self.did, forKey: .did)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encodeIfPresent(self.followersCount, forKey: .followersCount)
            try container.encodeIfPresent(self.followsCount, forKey: .followsCount)
            try container.encode(self.handle, forKey: .handle)
            try container.encodeIfPresent(self.indexedAt, forKey: .indexedAt)
            try container.encodeIfPresent(self.joinedViaStarterPack, forKey: .joinedViaStarterPack)
            try container.encodeIfPresent(self.labels, forKey: .labels)
            try container.encodeIfPresent(self.pinnedPost, forKey: .pinnedPost)
            try container.encodeIfPresent(self.postsCount, forKey: .postsCount)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encodeIfPresent(self.verification, forKey: .verification)
            try container.encodeIfPresent(self.viewer, forKey: .viewer)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_SavedFeed: Codable, Sendable {
        public var id: String
        public var pinned: Bool
        public var type: ActorDefs_SavedFeed_Type
        public var value: String
        public let _unknownValues: [String: AnyCodable]

        public init(id: String, pinned: Bool, type: ActorDefs_SavedFeed_Type, value: String) {
            self.id = id
            self.pinned = pinned
            self.type = type
            self.value = value
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case id
            case pinned
            case type
            case value
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.id = try keyedContainer.decode(String.self, forKey: .id)
            self.pinned = try keyedContainer.decode(Bool.self, forKey: .pinned)
            self.type = try keyedContainer.decode(ActorDefs_SavedFeed_Type.self, forKey: .type)
            self.value = try keyedContainer.decode(String.self, forKey: .value)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.id, forKey: .id)
            try container.encode(self.pinned, forKey: .pinned)
            try container.encode(self.type, forKey: .type)
            try container.encode(self.value, forKey: .value)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_SavedFeed_Type: RawRepresentable, Codable, Sendable {
        case feed
        case list
        case timeline
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "feed":
                self = .feed
            case "list":
                self = .list
            case "timeline":
                self = .timeline
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .feed:
                "feed"
            case .list:
                "list"
            case .timeline:
                "timeline"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_SavedFeedsPref: Codable, Sendable {
        public var pinned: [String]
        public var saved: [String]
        public var timelineIndex: Int?
        public let _unknownValues: [String: AnyCodable]

        public init(pinned: [String], saved: [String], timelineIndex: Int? = nil) {
            self.pinned = pinned
            self.saved = saved
            self.timelineIndex = timelineIndex
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case pinned
            case saved
            case timelineIndex
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.pinned = try keyedContainer.decode([String].self, forKey: .pinned)
            self.saved = try keyedContainer.decode([String].self, forKey: .saved)
            self.timelineIndex = try keyedContainer.decodeIfPresent(Int.self, forKey: .timelineIndex)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.pinned, forKey: .pinned)
            try container.encode(self.saved, forKey: .saved)
            try container.encodeIfPresent(self.timelineIndex, forKey: .timelineIndex)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_SavedFeedsPrefV2: Codable, Sendable {
        public var items: [ActorDefs_SavedFeed]
        public let _unknownValues: [String: AnyCodable]

        public init(items: [ActorDefs_SavedFeed]) {
            self.items = items
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case items
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.items = try keyedContainer.decode([ActorDefs_SavedFeed].self, forKey: .items)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.items, forKey: .items)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_StatusView: Codable, Sendable {
        public var embed: ActorDefs_StatusView_Embed?
        public var expiresAt: String?
        public var isActive: Bool?
        public var record: UnknownATPValue
        public var status: ActorDefs_StatusView_Status
        public let _unknownValues: [String: AnyCodable]

        public init(embed: ActorDefs_StatusView_Embed? = nil, expiresAt: String? = nil, isActive: Bool? = nil, record: UnknownATPValue, status: ActorDefs_StatusView_Status) {
            self.embed = embed
            self.expiresAt = expiresAt
            self.isActive = isActive
            self.record = record
            self.status = status
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case embed
            case expiresAt
            case isActive
            case record
            case status
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.embed = try keyedContainer.decodeIfPresent(ActorDefs_StatusView_Embed.self, forKey: .embed)
            self.expiresAt = try keyedContainer.decodeIfPresent(String.self, forKey: .expiresAt)
            self.isActive = try keyedContainer.decodeIfPresent(Bool.self, forKey: .isActive)
            self.record = try keyedContainer.decode(UnknownATPValue.self, forKey: .record)
            self.status = try keyedContainer.decode(ActorDefs_StatusView_Status.self, forKey: .status)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.embed, forKey: .embed)
            try container.encodeIfPresent(self.expiresAt, forKey: .expiresAt)
            try container.encodeIfPresent(self.isActive, forKey: .isActive)
            try container.encode(self.record, forKey: .record)
            try container.encode(self.status, forKey: .status)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_StatusView_Embed: Codable, Sendable {
        case embedExternalView(EmbedExternal_View)
        case _other(UnknownRecord)

        enum CodingKeys: String, CodingKey {
            case type = "$type"
        }

        public init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(String.self, forKey: .type)
            switch type {
            case "app.bsky.embed.external#view":
                self = try .embedExternalView(.init(from: decoder))
            default:
                self = try ._other(.init(from: decoder))
            }
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            switch self {
            case let .embedExternalView(value):
                try container.encode("app.bsky.embed.external#view", forKey: .type)
                try value.encode(to: encoder)
            case let ._other(value):
                try value.encode(to: encoder)
            }
        }
    }

    public indirect enum ActorDefs_StatusView_Status: RawRepresentable, Codable, Sendable {
        case appBskyActorStatusLive
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "app.bsky.actor.status#live":
                self = .appBskyActorStatusLive
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .appBskyActorStatusLive:
                "app.bsky.actor.status#live"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_ThreadViewPref: Codable, Sendable {
        public var prioritizeFollowedUsers: Bool?
        public var sort: ActorDefs_ThreadViewPref_Sort?
        public let _unknownValues: [String: AnyCodable]

        public init(prioritizeFollowedUsers: Bool? = nil, sort: ActorDefs_ThreadViewPref_Sort? = nil) {
            self.prioritizeFollowedUsers = prioritizeFollowedUsers
            self.sort = sort
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case prioritizeFollowedUsers
            case sort
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.prioritizeFollowedUsers = try keyedContainer.decodeIfPresent(Bool.self, forKey: .prioritizeFollowedUsers)
            self.sort = try keyedContainer.decodeIfPresent(ActorDefs_ThreadViewPref_Sort.self, forKey: .sort)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.prioritizeFollowedUsers, forKey: .prioritizeFollowedUsers)
            try container.encodeIfPresent(self.sort, forKey: .sort)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_ThreadViewPref_Sort: RawRepresentable, Codable, Sendable {
        case oldest
        case newest
        case mostLikes
        case random
        case hotness
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "oldest":
                self = .oldest
            case "newest":
                self = .newest
            case "most-likes":
                self = .mostLikes
            case "random":
                self = .random
            case "hotness":
                self = .hotness
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .oldest:
                "oldest"
            case .newest:
                "newest"
            case .mostLikes:
                "most-likes"
            case .random:
                "random"
            case .hotness:
                "hotness"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_VerificationPrefs: Codable, Sendable {
        public var hideBadges: Bool?
        public let _unknownValues: [String: AnyCodable]

        public init(hideBadges: Bool? = nil) {
            self.hideBadges = hideBadges
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case hideBadges
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.hideBadges = try keyedContainer.decodeIfPresent(Bool.self, forKey: .hideBadges)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.hideBadges, forKey: .hideBadges)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_VerificationState: Codable, Sendable {
        public var trustedVerifierStatus: ActorDefs_VerificationState_TrustedVerifierStatus
        public var verifications: [ActorDefs_VerificationView]
        public var verifiedStatus: ActorDefs_VerificationState_VerifiedStatus
        public let _unknownValues: [String: AnyCodable]

        public init(trustedVerifierStatus: ActorDefs_VerificationState_TrustedVerifierStatus, verifications: [ActorDefs_VerificationView], verifiedStatus: ActorDefs_VerificationState_VerifiedStatus) {
            self.trustedVerifierStatus = trustedVerifierStatus
            self.verifications = verifications
            self.verifiedStatus = verifiedStatus
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case trustedVerifierStatus
            case verifications
            case verifiedStatus
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.trustedVerifierStatus = try keyedContainer.decode(ActorDefs_VerificationState_TrustedVerifierStatus.self, forKey: .trustedVerifierStatus)
            self.verifications = try keyedContainer.decode([ActorDefs_VerificationView].self, forKey: .verifications)
            self.verifiedStatus = try keyedContainer.decode(ActorDefs_VerificationState_VerifiedStatus.self, forKey: .verifiedStatus)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.trustedVerifierStatus, forKey: .trustedVerifierStatus)
            try container.encode(self.verifications, forKey: .verifications)
            try container.encode(self.verifiedStatus, forKey: .verifiedStatus)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_VerificationState_TrustedVerifierStatus: RawRepresentable, Codable, Sendable {
        case valid
        case invalid
        case none
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "valid":
                self = .valid
            case "invalid":
                self = .invalid
            case "none":
                self = .none
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .valid:
                "valid"
            case .invalid:
                "invalid"
            case .none:
                "none"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public indirect enum ActorDefs_VerificationState_VerifiedStatus: RawRepresentable, Codable, Sendable {
        case valid
        case invalid
        case none
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "valid":
                self = .valid
            case "invalid":
                self = .invalid
            case "none":
                self = .none
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .valid:
                "valid"
            case .invalid:
                "invalid"
            case .none:
                "none"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct ActorDefs_VerificationView: Codable, Sendable {
        public var createdAt: String
        public var isValid: Bool
        public var issuer: String
        public var uri: String
        public let _unknownValues: [String: AnyCodable]

        public init(createdAt: String, isValid: Bool, issuer: String, uri: String) {
            self.createdAt = createdAt
            self.isValid = isValid
            self.issuer = issuer
            self.uri = uri
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case createdAt
            case isValid
            case issuer
            case uri
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.createdAt = try keyedContainer.decode(String.self, forKey: .createdAt)
            self.isValid = try keyedContainer.decode(Bool.self, forKey: .isValid)
            self.issuer = try keyedContainer.decode(String.self, forKey: .issuer)
            self.uri = try keyedContainer.decode(String.self, forKey: .uri)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.createdAt, forKey: .createdAt)
            try container.encode(self.isValid, forKey: .isValid)
            try container.encode(self.issuer, forKey: .issuer)
            try container.encode(self.uri, forKey: .uri)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct ActorDefs_ViewerState: Codable, Sendable {
        public var activitySubscription: NotificationDefs_ActivitySubscription?
        public var blockedBy: Bool?
        public var blocking: String?
        public var blockingByList: GraphDefs_ListViewBasic?
        public var followedBy: String?
        public var following: String?
        public var knownFollowers: ActorDefs_KnownFollowers?
        public var muted: Bool?
        public var mutedByList: GraphDefs_ListViewBasic?
        public let _unknownValues: [String: AnyCodable]

        public init(activitySubscription: NotificationDefs_ActivitySubscription? = nil, blockedBy: Bool? = nil, blocking: String? = nil, blockingByList: GraphDefs_ListViewBasic? = nil, followedBy: String? = nil, following: String? = nil, knownFollowers: ActorDefs_KnownFollowers? = nil, muted: Bool? = nil, mutedByList: GraphDefs_ListViewBasic? = nil) {
            self.activitySubscription = activitySubscription
            self.blockedBy = blockedBy
            self.blocking = blocking
            self.blockingByList = blockingByList
            self.followedBy = followedBy
            self.following = following
            self.knownFollowers = knownFollowers
            self.muted = muted
            self.mutedByList = mutedByList
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case activitySubscription
            case blockedBy
            case blocking
            case blockingByList
            case followedBy
            case following
            case knownFollowers
            case muted
            case mutedByList
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.activitySubscription = try keyedContainer.decodeIfPresent(NotificationDefs_ActivitySubscription.self, forKey: .activitySubscription)
            self.blockedBy = try keyedContainer.decodeIfPresent(Bool.self, forKey: .blockedBy)
            self.blocking = try keyedContainer.decodeIfPresent(String.self, forKey: .blocking)
            self.blockingByList = try keyedContainer.decodeIfPresent(GraphDefs_ListViewBasic.self, forKey: .blockingByList)
            self.followedBy = try keyedContainer.decodeIfPresent(String.self, forKey: .followedBy)
            self.following = try keyedContainer.decodeIfPresent(String.self, forKey: .following)
            self.knownFollowers = try keyedContainer.decodeIfPresent(ActorDefs_KnownFollowers.self, forKey: .knownFollowers)
            self.muted = try keyedContainer.decodeIfPresent(Bool.self, forKey: .muted)
            self.mutedByList = try keyedContainer.decodeIfPresent(GraphDefs_ListViewBasic.self, forKey: .mutedByList)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.activitySubscription, forKey: .activitySubscription)
            try container.encodeIfPresent(self.blockedBy, forKey: .blockedBy)
            try container.encodeIfPresent(self.blocking, forKey: .blocking)
            try container.encodeIfPresent(self.blockingByList, forKey: .blockingByList)
            try container.encodeIfPresent(self.followedBy, forKey: .followedBy)
            try container.encodeIfPresent(self.following, forKey: .following)
            try container.encodeIfPresent(self.knownFollowers, forKey: .knownFollowers)
            try container.encodeIfPresent(self.muted, forKey: .muted)
            try container.encodeIfPresent(self.mutedByList, forKey: .mutedByList)
            try _unknownValues.encode(to: encoder)
        }
    }
}

//
// DO NOT EDIT
//
// Generated by swift-atproto
//

import SwiftAtproto
import Foundation

extension appbskytypes {
    public struct UnspeccedDefs_AgeAssuranceEvent: Codable, Sendable {
        public var attemptId: String
        public var completeIp: String?
        public var completeUa: String?
        public var createdAt: String
        public var email: String?
        public var initIp: String?
        public var initUa: String?
        public var status: UnspeccedDefs_AgeAssuranceEvent_Status
        public var _unknownValues: [String: AnyCodable]

        public init(attemptId: String, completeIp: String? = nil, completeUa: String? = nil, createdAt: String, email: String? = nil, initIp: String? = nil, initUa: String? = nil, status: UnspeccedDefs_AgeAssuranceEvent_Status) {
            self.attemptId = attemptId
            self.completeIp = completeIp
            self.completeUa = completeUa
            self.createdAt = createdAt
            self.email = email
            self.initIp = initIp
            self.initUa = initUa
            self.status = status
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case attemptId
            case completeIp
            case completeUa
            case createdAt
            case email
            case initIp
            case initUa
            case status
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.attemptId = try keyedContainer.decode(String.self, forKey: .attemptId)
            self.completeIp = try keyedContainer.decodeIfPresent(String.self, forKey: .completeIp)
            self.completeUa = try keyedContainer.decodeIfPresent(String.self, forKey: .completeUa)
            self.createdAt = try keyedContainer.decode(String.self, forKey: .createdAt)
            self.email = try keyedContainer.decodeIfPresent(String.self, forKey: .email)
            self.initIp = try keyedContainer.decodeIfPresent(String.self, forKey: .initIp)
            self.initUa = try keyedContainer.decodeIfPresent(String.self, forKey: .initUa)
            self.status = try keyedContainer.decode(UnspeccedDefs_AgeAssuranceEvent_Status.self, forKey: .status)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.attemptId, forKey: .attemptId)
            try container.encodeIfPresent(self.completeIp, forKey: .completeIp)
            try container.encodeIfPresent(self.completeUa, forKey: .completeUa)
            try container.encode(self.createdAt, forKey: .createdAt)
            try container.encodeIfPresent(self.email, forKey: .email)
            try container.encodeIfPresent(self.initIp, forKey: .initIp)
            try container.encodeIfPresent(self.initUa, forKey: .initUa)
            try container.encode(self.status, forKey: .status)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum UnspeccedDefs_AgeAssuranceEvent_Status: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case unknown
        case pending
        case assured
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "unknown":
                self = .unknown
            case "pending":
                self = .pending
            case "assured":
                self = .assured
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .unknown:
                "unknown"
            case .pending:
                "pending"
            case .assured:
                "assured"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_AgeAssuranceState: Codable, Sendable {
        public var lastInitiatedAt: String?
        public var status: UnspeccedDefs_AgeAssuranceState_Status
        public var _unknownValues: [String: AnyCodable]

        public init(lastInitiatedAt: String? = nil, status: UnspeccedDefs_AgeAssuranceState_Status) {
            self.lastInitiatedAt = lastInitiatedAt
            self.status = status
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case lastInitiatedAt
            case status
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.lastInitiatedAt = try keyedContainer.decodeIfPresent(String.self, forKey: .lastInitiatedAt)
            self.status = try keyedContainer.decode(UnspeccedDefs_AgeAssuranceState_Status.self, forKey: .status)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.lastInitiatedAt, forKey: .lastInitiatedAt)
            try container.encode(self.status, forKey: .status)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum UnspeccedDefs_AgeAssuranceState_Status: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case unknown
        case pending
        case assured
        case blocked
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "unknown":
                self = .unknown
            case "pending":
                self = .pending
            case "assured":
                self = .assured
            case "blocked":
                self = .blocked
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .unknown:
                "unknown"
            case .pending:
                "pending"
            case .assured:
                "assured"
            case .blocked:
                "blocked"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_SkeletonSearchActor: Codable, Sendable {
        public var did: String
        public var _unknownValues: [String: AnyCodable]

        public init(did: String) {
            self.did = did
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case did
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.did, forKey: .did)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_SkeletonSearchPost: Codable, Sendable {
        public var uri: String
        public var _unknownValues: [String: AnyCodable]

        public init(uri: String) {
            self.uri = uri
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case uri
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.uri = try keyedContainer.decode(String.self, forKey: .uri)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.uri, forKey: .uri)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_SkeletonSearchStarterPack: Codable, Sendable {
        public var uri: String
        public var _unknownValues: [String: AnyCodable]

        public init(uri: String) {
            self.uri = uri
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case uri
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.uri = try keyedContainer.decode(String.self, forKey: .uri)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.uri, forKey: .uri)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_SkeletonTrend: Codable, Sendable {
        public var category: String?
        public var dids: [String]
        public var displayName: String
        public var link: String
        public var postCount: Int
        public var startedAt: String
        public var status: UnspeccedDefs_SkeletonTrend_Status?
        public var topic: String
        public var _unknownValues: [String: AnyCodable]

        public init(category: String? = nil, dids: [String], displayName: String, link: String, postCount: Int, startedAt: String, status: UnspeccedDefs_SkeletonTrend_Status? = nil, topic: String) {
            self.category = category
            self.dids = dids
            self.displayName = displayName
            self.link = link
            self.postCount = postCount
            self.startedAt = startedAt
            self.status = status
            self.topic = topic
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case category
            case dids
            case displayName
            case link
            case postCount
            case startedAt
            case status
            case topic
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.category = try keyedContainer.decodeIfPresent(String.self, forKey: .category)
            self.dids = try keyedContainer.decode([String].self, forKey: .dids)
            self.displayName = try keyedContainer.decode(String.self, forKey: .displayName)
            self.link = try keyedContainer.decode(String.self, forKey: .link)
            self.postCount = try keyedContainer.decode(Int.self, forKey: .postCount)
            self.startedAt = try keyedContainer.decode(String.self, forKey: .startedAt)
            self.status = try keyedContainer.decodeIfPresent(UnspeccedDefs_SkeletonTrend_Status.self, forKey: .status)
            self.topic = try keyedContainer.decode(String.self, forKey: .topic)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.category, forKey: .category)
            try container.encode(self.dids, forKey: .dids)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encode(self.link, forKey: .link)
            try container.encode(self.postCount, forKey: .postCount)
            try container.encode(self.startedAt, forKey: .startedAt)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encode(self.topic, forKey: .topic)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum UnspeccedDefs_SkeletonTrend_Status: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case hot
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "hot":
                self = .hot
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .hot:
                "hot"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_ThreadItemBlocked: Codable, Sendable {
        public var author: FeedDefs_BlockedAuthor
        public var _unknownValues: [String: AnyCodable]

        public init(author: FeedDefs_BlockedAuthor) {
            self.author = author
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case author
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.author = try keyedContainer.decode(FeedDefs_BlockedAuthor.self, forKey: .author)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.author, forKey: .author)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_ThreadItemNotFound: Codable, Sendable {
        public let type = "app.bsky.unspecced.defs#threadItemNotFound"
        public var _unknownValues: [String: AnyCodable]

        public init() {
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case type = "$type"
        }

        public init(from decoder: any Decoder) throws {
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_ThreadItemNoUnauthenticated: Codable, Sendable {
        public let type = "app.bsky.unspecced.defs#threadItemNoUnauthenticated"
        public var _unknownValues: [String: AnyCodable]

        public init() {
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case type = "$type"
        }

        public init(from decoder: any Decoder) throws {
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_ThreadItemPost: Codable, Sendable {
        public var hiddenByThreadgate: Bool
        public var moreParents: Bool
        public var moreReplies: Int
        public var mutedByViewer: Bool
        public var opThread: Bool
        public var post: FeedDefs_PostView
        public var _unknownValues: [String: AnyCodable]

        public init(hiddenByThreadgate: Bool, moreParents: Bool, moreReplies: Int, mutedByViewer: Bool, opThread: Bool, post: FeedDefs_PostView) {
            self.hiddenByThreadgate = hiddenByThreadgate
            self.moreParents = moreParents
            self.moreReplies = moreReplies
            self.mutedByViewer = mutedByViewer
            self.opThread = opThread
            self.post = post
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case hiddenByThreadgate
            case moreParents
            case moreReplies
            case mutedByViewer
            case opThread
            case post
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.hiddenByThreadgate = try keyedContainer.decode(Bool.self, forKey: .hiddenByThreadgate)
            self.moreParents = try keyedContainer.decode(Bool.self, forKey: .moreParents)
            self.moreReplies = try keyedContainer.decode(Int.self, forKey: .moreReplies)
            self.mutedByViewer = try keyedContainer.decode(Bool.self, forKey: .mutedByViewer)
            self.opThread = try keyedContainer.decode(Bool.self, forKey: .opThread)
            self.post = try keyedContainer.decode(FeedDefs_PostView.self, forKey: .post)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.hiddenByThreadgate, forKey: .hiddenByThreadgate)
            try container.encode(self.moreParents, forKey: .moreParents)
            try container.encode(self.moreReplies, forKey: .moreReplies)
            try container.encode(self.mutedByViewer, forKey: .mutedByViewer)
            try container.encode(self.opThread, forKey: .opThread)
            try container.encode(self.post, forKey: .post)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_TrendingTopic: Codable, Sendable {
        public var description: String?
        public var displayName: String?
        public var link: String
        public var topic: String
        public var _unknownValues: [String: AnyCodable]

        public init(description: String? = nil, displayName: String? = nil, link: String, topic: String) {
            self.description = description
            self.displayName = displayName
            self.link = link
            self.topic = topic
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case description
            case displayName
            case link
            case topic
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.description = try keyedContainer.decodeIfPresent(String.self, forKey: .description)
            self.displayName = try keyedContainer.decodeIfPresent(String.self, forKey: .displayName)
            self.link = try keyedContainer.decode(String.self, forKey: .link)
            self.topic = try keyedContainer.decode(String.self, forKey: .topic)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.description, forKey: .description)
            try container.encodeIfPresent(self.displayName, forKey: .displayName)
            try container.encode(self.link, forKey: .link)
            try container.encode(self.topic, forKey: .topic)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct UnspeccedDefs_TrendView: Codable, Sendable {
        public var actors: [ActorDefs_ProfileViewBasic]
        public var category: String?
        public var displayName: String
        public var link: String
        public var postCount: Int
        public var startedAt: String
        public var status: UnspeccedDefs_TrendView_Status?
        public var topic: String
        public var _unknownValues: [String: AnyCodable]

        public init(actors: [ActorDefs_ProfileViewBasic], category: String? = nil, displayName: String, link: String, postCount: Int, startedAt: String, status: UnspeccedDefs_TrendView_Status? = nil, topic: String) {
            self.actors = actors
            self.category = category
            self.displayName = displayName
            self.link = link
            self.postCount = postCount
            self.startedAt = startedAt
            self.status = status
            self.topic = topic
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case actors
            case category
            case displayName
            case link
            case postCount
            case startedAt
            case status
            case topic
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.actors = try keyedContainer.decode([ActorDefs_ProfileViewBasic].self, forKey: .actors)
            self.category = try keyedContainer.decodeIfPresent(String.self, forKey: .category)
            self.displayName = try keyedContainer.decode(String.self, forKey: .displayName)
            self.link = try keyedContainer.decode(String.self, forKey: .link)
            self.postCount = try keyedContainer.decode(Int.self, forKey: .postCount)
            self.startedAt = try keyedContainer.decode(String.self, forKey: .startedAt)
            self.status = try keyedContainer.decodeIfPresent(UnspeccedDefs_TrendView_Status.self, forKey: .status)
            self.topic = try keyedContainer.decode(String.self, forKey: .topic)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.actors, forKey: .actors)
            try container.encodeIfPresent(self.category, forKey: .category)
            try container.encode(self.displayName, forKey: .displayName)
            try container.encode(self.link, forKey: .link)
            try container.encode(self.postCount, forKey: .postCount)
            try container.encode(self.startedAt, forKey: .startedAt)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encode(self.topic, forKey: .topic)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum UnspeccedDefs_TrendView_Status: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case hot
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "hot":
                self = .hot
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .hot:
                "hot"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }
}

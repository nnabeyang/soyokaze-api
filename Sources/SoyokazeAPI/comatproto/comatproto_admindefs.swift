//
// DO NOT EDIT
//
// Generated by swift-atproto
//

import SwiftAtproto
import Foundation

extension comatprototypes {
    public struct AdminDefs_AccountView: Codable, Sendable {
        public var deactivatedAt: String?
        public var did: String
        public var email: String?
        public var emailConfirmedAt: String?
        public var handle: String
        public var indexedAt: String
        public var inviteNote: String?
        public var invitedBy: ServerDefs_InviteCode?
        public var invites: [ServerDefs_InviteCode]?
        public var invitesDisabled: Bool?
        public var relatedRecords: [LexiconTypeDecoder]?
        public var threatSignatures: [AdminDefs_ThreatSignature]?
        public var _unknownValues: [String: AnyCodable]

        public init(deactivatedAt: String? = nil, did: String, email: String? = nil, emailConfirmedAt: String? = nil, handle: String, indexedAt: String, inviteNote: String? = nil, invitedBy: ServerDefs_InviteCode? = nil, invites: [ServerDefs_InviteCode]? = nil, invitesDisabled: Bool? = nil, relatedRecords: [LexiconTypeDecoder]? = nil, threatSignatures: [AdminDefs_ThreatSignature]? = nil) {
            self.deactivatedAt = deactivatedAt
            self.did = did
            self.email = email
            self.emailConfirmedAt = emailConfirmedAt
            self.handle = handle
            self.indexedAt = indexedAt
            self.inviteNote = inviteNote
            self.invitedBy = invitedBy
            self.invites = invites
            self.invitesDisabled = invitesDisabled
            self.relatedRecords = relatedRecords
            self.threatSignatures = threatSignatures
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case deactivatedAt
            case did
            case email
            case emailConfirmedAt
            case handle
            case indexedAt
            case inviteNote
            case invitedBy
            case invites
            case invitesDisabled
            case relatedRecords
            case threatSignatures
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.deactivatedAt = try keyedContainer.decodeIfPresent(String.self, forKey: .deactivatedAt)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.email = try keyedContainer.decodeIfPresent(String.self, forKey: .email)
            self.emailConfirmedAt = try keyedContainer.decodeIfPresent(String.self, forKey: .emailConfirmedAt)
            self.handle = try keyedContainer.decode(String.self, forKey: .handle)
            self.indexedAt = try keyedContainer.decode(String.self, forKey: .indexedAt)
            self.inviteNote = try keyedContainer.decodeIfPresent(String.self, forKey: .inviteNote)
            self.invitedBy = try keyedContainer.decodeIfPresent(ServerDefs_InviteCode.self, forKey: .invitedBy)
            self.invites = try keyedContainer.decodeIfPresent([ServerDefs_InviteCode].self, forKey: .invites)
            self.invitesDisabled = try keyedContainer.decodeIfPresent(Bool.self, forKey: .invitesDisabled)
            self.relatedRecords = try keyedContainer.decodeIfPresent([LexiconTypeDecoder].self, forKey: .relatedRecords)
            self.threatSignatures = try keyedContainer.decodeIfPresent([AdminDefs_ThreatSignature].self, forKey: .threatSignatures)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.deactivatedAt, forKey: .deactivatedAt)
            try container.encode(self.did, forKey: .did)
            try container.encodeIfPresent(self.email, forKey: .email)
            try container.encodeIfPresent(self.emailConfirmedAt, forKey: .emailConfirmedAt)
            try container.encode(self.handle, forKey: .handle)
            try container.encode(self.indexedAt, forKey: .indexedAt)
            try container.encodeIfPresent(self.inviteNote, forKey: .inviteNote)
            try container.encodeIfPresent(self.invitedBy, forKey: .invitedBy)
            try container.encodeIfPresent(self.invites, forKey: .invites)
            try container.encodeIfPresent(self.invitesDisabled, forKey: .invitesDisabled)
            try container.encodeIfPresent(self.relatedRecords, forKey: .relatedRecords)
            try container.encodeIfPresent(self.threatSignatures, forKey: .threatSignatures)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct AdminDefs_RepoBlobRef: Codable, Sendable {
        public var cid: String
        public var did: String
        public var recordUri: String?
        public var _unknownValues: [String: AnyCodable]

        public init(cid: String, did: String, recordUri: String? = nil) {
            self.cid = cid
            self.did = did
            self.recordUri = recordUri
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case cid
            case did
            case recordUri
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.cid = try keyedContainer.decode(String.self, forKey: .cid)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.recordUri = try keyedContainer.decodeIfPresent(String.self, forKey: .recordUri)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.cid, forKey: .cid)
            try container.encode(self.did, forKey: .did)
            try container.encodeIfPresent(self.recordUri, forKey: .recordUri)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct AdminDefs_RepoRef: Codable, Sendable {
        public var did: String
        public var _unknownValues: [String: AnyCodable]

        public init(did: String) {
            self.did = did
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case did
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.did, forKey: .did)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct AdminDefs_StatusAttr: Codable, Sendable {
        public var applied: Bool
        public var ref: String?
        public var _unknownValues: [String: AnyCodable]

        public init(applied: Bool, ref: String? = nil) {
            self.applied = applied
            self.ref = ref
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case applied
            case ref
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.applied = try keyedContainer.decode(Bool.self, forKey: .applied)
            self.ref = try keyedContainer.decodeIfPresent(String.self, forKey: .ref)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.applied, forKey: .applied)
            try container.encodeIfPresent(self.ref, forKey: .ref)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct AdminDefs_ThreatSignature: Codable, Sendable {
        public var property: String
        public var value: String
        public var _unknownValues: [String: AnyCodable]

        public init(property: String, value: String) {
            self.property = property
            self.value = value
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case property
            case value
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.property = try keyedContainer.decode(String.self, forKey: .property)
            self.value = try keyedContainer.decode(String.self, forKey: .value)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.property, forKey: .property)
            try container.encode(self.value, forKey: .value)
            try _unknownValues.encode(to: encoder)
        }
    }
}

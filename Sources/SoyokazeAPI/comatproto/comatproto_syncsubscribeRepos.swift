//
// DO NOT EDIT
//
// Generated by swift-atproto
//

import SwiftAtproto
import Foundation

extension comatprototypes {
    public struct SyncSubscribeRepos_Account: Codable, Sendable {
        public var active: Bool
        public var did: String
        public var seq: Int
        public var status: SyncSubscribeRepos_Account_Status?
        public var time: String
        public var _unknownValues: [String: AnyCodable]

        public init(active: Bool, did: String, seq: Int, status: SyncSubscribeRepos_Account_Status? = nil, time: String) {
            self.active = active
            self.did = did
            self.seq = seq
            self.status = status
            self.time = time
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case active
            case did
            case seq
            case status
            case time
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.active = try keyedContainer.decode(Bool.self, forKey: .active)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.seq = try keyedContainer.decode(Int.self, forKey: .seq)
            self.status = try keyedContainer.decodeIfPresent(SyncSubscribeRepos_Account_Status.self, forKey: .status)
            self.time = try keyedContainer.decode(String.self, forKey: .time)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.active, forKey: .active)
            try container.encode(self.did, forKey: .did)
            try container.encode(self.seq, forKey: .seq)
            try container.encodeIfPresent(self.status, forKey: .status)
            try container.encode(self.time, forKey: .time)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum SyncSubscribeRepos_Account_Status: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case takendown
        case suspended
        case deleted
        case deactivated
        case desynchronized
        case throttled
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "takendown":
                self = .takendown
            case "suspended":
                self = .suspended
            case "deleted":
                self = .deleted
            case "deactivated":
                self = .deactivated
            case "desynchronized":
                self = .desynchronized
            case "throttled":
                self = .throttled
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .takendown:
                "takendown"
            case .suspended:
                "suspended"
            case .deleted:
                "deleted"
            case .deactivated:
                "deactivated"
            case .desynchronized:
                "desynchronized"
            case .throttled:
                "throttled"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct SyncSubscribeRepos_Commit: Codable, Sendable {
        public var blobs: [LexLink]
        public var blocks: Data
        public var commit: LexLink
        public var ops: [SyncSubscribeRepos_RepoOp]
        public var prevData: LexLink?
        public var rebase: Bool
        public var repo: String
        public var rev: String
        public var seq: Int
        public var since: String?
        public var time: String
        public var tooBig: Bool
        public var _unknownValues: [String: AnyCodable]

        public init(blobs: [LexLink], blocks: Data, commit: LexLink, ops: [SyncSubscribeRepos_RepoOp], prevData: LexLink? = nil, rebase: Bool, repo: String, rev: String, seq: Int, since: String? = nil, time: String, tooBig: Bool) {
            self.blobs = blobs
            self.blocks = blocks
            self.commit = commit
            self.ops = ops
            self.prevData = prevData
            self.rebase = rebase
            self.repo = repo
            self.rev = rev
            self.seq = seq
            self.since = since
            self.time = time
            self.tooBig = tooBig
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case blobs
            case blocks
            case commit
            case ops
            case prevData
            case rebase
            case repo
            case rev
            case seq
            case since
            case time
            case tooBig
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.blobs = try keyedContainer.decode([LexLink].self, forKey: .blobs)
            self.blocks = try keyedContainer.decode(Data.self, forKey: .blocks)
            self.commit = try keyedContainer.decode(LexLink.self, forKey: .commit)
            self.ops = try keyedContainer.decode([SyncSubscribeRepos_RepoOp].self, forKey: .ops)
            self.prevData = try keyedContainer.decodeIfPresent(LexLink.self, forKey: .prevData)
            self.rebase = try keyedContainer.decode(Bool.self, forKey: .rebase)
            self.repo = try keyedContainer.decode(String.self, forKey: .repo)
            self.rev = try keyedContainer.decode(String.self, forKey: .rev)
            self.seq = try keyedContainer.decode(Int.self, forKey: .seq)
            self.since = try keyedContainer.decodeIfPresent(String.self, forKey: .since)
            self.time = try keyedContainer.decode(String.self, forKey: .time)
            self.tooBig = try keyedContainer.decode(Bool.self, forKey: .tooBig)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.blobs, forKey: .blobs)
            try container.encode(self.blocks, forKey: .blocks)
            try container.encode(self.commit, forKey: .commit)
            try container.encode(self.ops, forKey: .ops)
            try container.encodeIfPresent(self.prevData, forKey: .prevData)
            try container.encode(self.rebase, forKey: .rebase)
            try container.encode(self.repo, forKey: .repo)
            try container.encode(self.rev, forKey: .rev)
            try container.encode(self.seq, forKey: .seq)
            try container.encodeIfPresent(self.since, forKey: .since)
            try container.encode(self.time, forKey: .time)
            try container.encode(self.tooBig, forKey: .tooBig)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct SyncSubscribeRepos_Identity: Codable, Sendable {
        public var did: String
        public var handle: String?
        public var seq: Int
        public var time: String
        public var _unknownValues: [String: AnyCodable]

        public init(did: String, handle: String? = nil, seq: Int, time: String) {
            self.did = did
            self.handle = handle
            self.seq = seq
            self.time = time
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case did
            case handle
            case seq
            case time
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.handle = try keyedContainer.decodeIfPresent(String.self, forKey: .handle)
            self.seq = try keyedContainer.decode(Int.self, forKey: .seq)
            self.time = try keyedContainer.decode(String.self, forKey: .time)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.did, forKey: .did)
            try container.encodeIfPresent(self.handle, forKey: .handle)
            try container.encode(self.seq, forKey: .seq)
            try container.encode(self.time, forKey: .time)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct SyncSubscribeRepos_Info: Codable, Sendable {
        public var message: String?
        public var name: SyncSubscribeRepos_Info_Name
        public var _unknownValues: [String: AnyCodable]

        public init(message: String? = nil, name: SyncSubscribeRepos_Info_Name) {
            self.message = message
            self.name = name
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case message
            case name
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.message = try keyedContainer.decodeIfPresent(String.self, forKey: .message)
            self.name = try keyedContainer.decode(SyncSubscribeRepos_Info_Name.self, forKey: .name)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.message, forKey: .message)
            try container.encode(self.name, forKey: .name)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum SyncSubscribeRepos_Info_Name: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case outdatedcursor
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "OutdatedCursor":
                self = .outdatedcursor
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .outdatedcursor:
                "OutdatedCursor"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct SyncSubscribeRepos_RepoOp: Codable, Sendable {
        public var action: SyncSubscribeRepos_RepoOp_Action
        public var cid: LexLink?
        public var path: String
        public var prev: LexLink?
        public var _unknownValues: [String: AnyCodable]

        public init(action: SyncSubscribeRepos_RepoOp_Action, cid: LexLink? = nil, path: String, prev: LexLink? = nil) {
            self.action = action
            self.cid = cid
            self.path = path
            self.prev = prev
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case action
            case cid
            case path
            case prev
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.action = try keyedContainer.decode(SyncSubscribeRepos_RepoOp_Action.self, forKey: .action)
            self.cid = try keyedContainer.decodeIfPresent(LexLink.self, forKey: .cid)
            self.path = try keyedContainer.decode(String.self, forKey: .path)
            self.prev = try keyedContainer.decodeIfPresent(LexLink.self, forKey: .prev)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.action, forKey: .action)
            try container.encodeIfPresent(self.cid, forKey: .cid)
            try container.encode(self.path, forKey: .path)
            try container.encodeIfPresent(self.prev, forKey: .prev)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum SyncSubscribeRepos_RepoOp_Action: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case create
        case update
        case delete
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "create":
                self = .create
            case "update":
                self = .update
            case "delete":
                self = .delete
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .create:
                "create"
            case .update:
                "update"
            case .delete:
                "delete"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct SyncSubscribeRepos_Sync: Codable, Sendable {
        public var blocks: Data
        public var did: String
        public var rev: String
        public var seq: Int
        public var time: String
        public var _unknownValues: [String: AnyCodable]

        public init(blocks: Data, did: String, rev: String, seq: Int, time: String) {
            self.blocks = blocks
            self.did = did
            self.rev = rev
            self.seq = seq
            self.time = time
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case blocks
            case did
            case rev
            case seq
            case time
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.blocks = try keyedContainer.decode(Data.self, forKey: .blocks)
            self.did = try keyedContainer.decode(String.self, forKey: .did)
            self.rev = try keyedContainer.decode(String.self, forKey: .rev)
            self.seq = try keyedContainer.decode(Int.self, forKey: .seq)
            self.time = try keyedContainer.decode(String.self, forKey: .time)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.blocks, forKey: .blocks)
            try container.encode(self.did, forKey: .did)
            try container.encode(self.rev, forKey: .rev)
            try container.encode(self.seq, forKey: .seq)
            try container.encode(self.time, forKey: .time)
            try _unknownValues.encode(to: encoder)
        }
    }
}

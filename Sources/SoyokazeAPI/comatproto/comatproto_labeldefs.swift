//
// DO NOT EDIT
//
// Generated by swift-atproto
//

import SwiftAtproto
import Foundation

extension comatprototypes {
    public struct LabelDefs_Label: Codable, Sendable {
        public var cid: String?
        public var cts: String
        public var exp: String?
        public var neg: Bool?
        public var sig: Data?
        public var src: String
        public var uri: String
        public var val: String
        public var ver: Int?
        public var _unknownValues: [String: AnyCodable]

        public init(cid: String? = nil, cts: String, exp: String? = nil, neg: Bool? = nil, sig: Data? = nil, src: String, uri: String, val: String, ver: Int? = nil) {
            self.cid = cid
            self.cts = cts
            self.exp = exp
            self.neg = neg
            self.sig = sig
            self.src = src
            self.uri = uri
            self.val = val
            self.ver = ver
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case cid
            case cts
            case exp
            case neg
            case sig
            case src
            case uri
            case val
            case ver
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.cid = try keyedContainer.decodeIfPresent(String.self, forKey: .cid)
            self.cts = try keyedContainer.decode(String.self, forKey: .cts)
            self.exp = try keyedContainer.decodeIfPresent(String.self, forKey: .exp)
            self.neg = try keyedContainer.decodeIfPresent(Bool.self, forKey: .neg)
            self.sig = try keyedContainer.decodeIfPresent(Data.self, forKey: .sig)
            self.src = try keyedContainer.decode(String.self, forKey: .src)
            self.uri = try keyedContainer.decode(String.self, forKey: .uri)
            self.val = try keyedContainer.decode(String.self, forKey: .val)
            self.ver = try keyedContainer.decodeIfPresent(Int.self, forKey: .ver)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.cid, forKey: .cid)
            try container.encode(self.cts, forKey: .cts)
            try container.encodeIfPresent(self.exp, forKey: .exp)
            try container.encodeIfPresent(self.neg, forKey: .neg)
            try container.encodeIfPresent(self.sig, forKey: .sig)
            try container.encode(self.src, forKey: .src)
            try container.encode(self.uri, forKey: .uri)
            try container.encode(self.val, forKey: .val)
            try container.encodeIfPresent(self.ver, forKey: .ver)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum LabelDefs_LabelValue: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case hide
        case noPromote
        case warn
        case noUnauthenticated
        case dmcaViolation
        case doxxing
        case porn
        case sexual
        case nudity
        case nsfl
        case gore
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "!hide":
                self = .hide
            case "!no-promote":
                self = .noPromote
            case "!warn":
                self = .warn
            case "!no-unauthenticated":
                self = .noUnauthenticated
            case "dmca-violation":
                self = .dmcaViolation
            case "doxxing":
                self = .doxxing
            case "porn":
                self = .porn
            case "sexual":
                self = .sexual
            case "nudity":
                self = .nudity
            case "nsfl":
                self = .nsfl
            case "gore":
                self = .gore
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .hide:
                "!hide"
            case .noPromote:
                "!no-promote"
            case .warn:
                "!warn"
            case .noUnauthenticated:
                "!no-unauthenticated"
            case .dmcaViolation:
                "dmca-violation"
            case .doxxing:
                "doxxing"
            case .porn:
                "porn"
            case .sexual:
                "sexual"
            case .nudity:
                "nudity"
            case .nsfl:
                "nsfl"
            case .gore:
                "gore"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct LabelDefs_LabelValueDefinition: Codable, Sendable {
        public var adultOnly: Bool?
        public var blurs: LabelDefs_LabelValueDefinition_Blurs
        public var defaultSetting: LabelDefs_LabelValueDefinition_DefaultSetting?
        public var identifier: String
        public var locales: [LabelDefs_LabelValueDefinitionStrings]
        public var severity: LabelDefs_LabelValueDefinition_Severity
        public var _unknownValues: [String: AnyCodable]

        public init(adultOnly: Bool? = nil, blurs: LabelDefs_LabelValueDefinition_Blurs, defaultSetting: LabelDefs_LabelValueDefinition_DefaultSetting? = nil, identifier: String, locales: [LabelDefs_LabelValueDefinitionStrings], severity: LabelDefs_LabelValueDefinition_Severity) {
            self.adultOnly = adultOnly
            self.blurs = blurs
            self.defaultSetting = defaultSetting
            self.identifier = identifier
            self.locales = locales
            self.severity = severity
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case adultOnly
            case blurs
            case defaultSetting
            case identifier
            case locales
            case severity
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.adultOnly = try keyedContainer.decodeIfPresent(Bool.self, forKey: .adultOnly)
            self.blurs = try keyedContainer.decode(LabelDefs_LabelValueDefinition_Blurs.self, forKey: .blurs)
            self.defaultSetting = try keyedContainer.decodeIfPresent(LabelDefs_LabelValueDefinition_DefaultSetting.self, forKey: .defaultSetting)
            self.identifier = try keyedContainer.decode(String.self, forKey: .identifier)
            self.locales = try keyedContainer.decode([LabelDefs_LabelValueDefinitionStrings].self, forKey: .locales)
            self.severity = try keyedContainer.decode(LabelDefs_LabelValueDefinition_Severity.self, forKey: .severity)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encodeIfPresent(self.adultOnly, forKey: .adultOnly)
            try container.encode(self.blurs, forKey: .blurs)
            try container.encodeIfPresent(self.defaultSetting, forKey: .defaultSetting)
            try container.encode(self.identifier, forKey: .identifier)
            try container.encode(self.locales, forKey: .locales)
            try container.encode(self.severity, forKey: .severity)
            try _unknownValues.encode(to: encoder)
        }
    }

    public indirect enum LabelDefs_LabelValueDefinition_Blurs: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case content
        case media
        case none
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "content":
                self = .content
            case "media":
                self = .media
            case "none":
                self = .none
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .content:
                "content"
            case .media:
                "media"
            case .none:
                "none"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public indirect enum LabelDefs_LabelValueDefinition_DefaultSetting: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case ignore
        case warn
        case hide
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "ignore":
                self = .ignore
            case "warn":
                self = .warn
            case "hide":
                self = .hide
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .ignore:
                "ignore"
            case .warn:
                "warn"
            case .hide:
                "hide"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public indirect enum LabelDefs_LabelValueDefinition_Severity: RawRepresentable, Codable, Sendable {
        public typealias RawValue = String

        case inform
        case alert
        case none
        case _other(String)

        public init(rawValue: String) {
            switch rawValue {
            case "inform":
                self = .inform
            case "alert":
                self = .alert
            case "none":
                self = .none
            default:
                self = ._other(rawValue)
            }
        }

        public var rawValue: String {
            switch self {
            case .inform:
                "inform"
            case .alert:
                "alert"
            case .none:
                "none"
            case let ._other(value):
                value
            }
        }

        public init(from decoder: any Decoder) throws {
            let rawValue = try String(from: decoder)
            self = Self(rawValue: rawValue)
        }

        public func encode(to encoder: any Encoder) throws {
            try rawValue.encode(to: encoder)
        }
    }

    public struct LabelDefs_LabelValueDefinitionStrings: Codable, Sendable {
        public var description: String
        public var lang: String
        public var name: String
        public var _unknownValues: [String: AnyCodable]

        public init(description: String, lang: String, name: String) {
            self.description = description
            self.lang = lang
            self.name = name
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case description
            case lang
            case name
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.description = try keyedContainer.decode(String.self, forKey: .description)
            self.lang = try keyedContainer.decode(String.self, forKey: .lang)
            self.name = try keyedContainer.decode(String.self, forKey: .name)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.description, forKey: .description)
            try container.encode(self.lang, forKey: .lang)
            try container.encode(self.name, forKey: .name)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct LabelDefs_SelfLabel: Codable, Sendable {
        public var val: String
        public var _unknownValues: [String: AnyCodable]

        public init(val: String) {
            self.val = val
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case val
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.val = try keyedContainer.decode(String.self, forKey: .val)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.val, forKey: .val)
            try _unknownValues.encode(to: encoder)
        }
    }

    public struct LabelDefs_SelfLabels: Codable, Sendable {
        public var values: [LabelDefs_SelfLabel]
        public var _unknownValues: [String: AnyCodable]

        public init(values: [LabelDefs_SelfLabel]) {
            self.values = values
            self._unknownValues = [:]
        }

        enum CodingKeys: String, CodingKey {
            case values
        }

        public init(from decoder: any Decoder) throws {
            let keyedContainer = try decoder.container(keyedBy: CodingKeys.self)
            self.values = try keyedContainer.decode([LabelDefs_SelfLabel].self, forKey: .values)
            let unknownContainer = try decoder.container(keyedBy: AnyCodingKeys.self)
            var _unknownValues = [String: AnyCodable]()
            for key in unknownContainer.allKeys {
                guard CodingKeys(rawValue: key.stringValue) == nil else {
                    continue
                }
                _unknownValues[key.stringValue] = try unknownContainer.decode(AnyCodable.self, forKey: key)
            }
            self._unknownValues = _unknownValues
        }

        public func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.values, forKey: .values)
            try _unknownValues.encode(to: encoder)
        }
    }
}
